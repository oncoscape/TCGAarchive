/*
This is the code to generate a master patient ID table from each disease's collections other than clinical collections.
requires: mongoose
          collection_counts.json.json generated by generate_collections_counts.js
          schema_tcga.json
Purposes
        - substratify the entire collections to dataType collections
          and run schemas.json ajv validation on each collection
          error message at the document level will be reported
*/
var jsonfile = require("jsonfile");
var asyncLoop = require('node-async-loop');
const mongoose = require("mongoose");
 
var ajvMsg, collection, schemas, ptList;
 
jsonfile.readFile("../datasourceTesting/ptList.json", function(err, obj){
  ptList = obj;
});


jsonfile.readFile("../datasourceTesting/ajv_tcga_v2.json", function(err, obj) {
  ajvMsg = obj;
});

jsonfile.readFile("../schemas.json", function(err, obj) {
  schemas = obj;
});

var diseases = ajvMsg.map(function(a){return a.disease;});
diseases = diseases.unique();
 
mongoose.connect(
    'mongodb://oncoscape-dev-db1.sttrcancer.io:27017,oncoscape-dev-db2.sttrcancer.io:27017,oncoscape-dev-db3.sttrcancer.io:27017/tcga?authSource=admin', {
        db: {
            native_parser: true
        },
        server: {
            poolSize: 5,
            reconnectTries: Number.MAX_VALUE
        },
        replset: {
            rs_name: 'rs0'
        },
        user: 'oncoscapeRead',
        pass: 'i1f4d9botHD4xnZ'
    });
 
var connection = mongoose.connection;
var status = [];



//connection.once('open', function(){
    var db = connection.db;
    var index = 0;
    var ajvMsg_length = ajvMsg.length;
    /* This section theoretically runs throughout the entire DB, but will cause memory leak
     */
    asyncLoop(ajvMsg, function(d, next){  
      console.log("*************", d.collection);

      // var disease_ajvMsg = ajvMsg.findCollectionsByDisease(d); 
      // var ajvMsg_length = disease_ajvMsg.length; 
      // var index = 0;
      
      var obtainPtIDs = function(d){
        // var tableName = disease_ajvMsg[index].collection;
        // var t = disease_ajvMsg[index].type;
        var tableName = d.collection;
        var t = d.type;
        var collection = db.collection(tableName);
        var cursor = collection.find();
        var elem = d;
        elem.ptIDs = [];
        var count = 0;
        
        if(["mut", "mut01", "methylation", "rna", "protein", "cnv"].indexOf(t) > -1){
          console.log('within molecular');
          cursor.each(function(err, item){
            if(item != null){
              elem.ptIDs = elem.ptIDs.concat(Object.keys(item.patients)).unique();
            }else{
              return elem;
            }
          });
        }else
        if(t == "color"){
            console.log('within color');
            cursor.each(function(err, item){
              if(item != null){
                item.data.forEach(function(e){
                  elem.ptIDs = elem.ptIDs.concat(e.values).unique();
                });
              }else{
                return elem;
              }
            });
          }else if(t == "events"){
            console.log("within events");
            cursor.each(function(err, item){
              if(item != null){
                elem.ptIDs = elem.ptIDs.concat(Object.keys(item)).unique();
              }else{
                return elem;
              }
            });
          }else if(["patient", "drug", "newTumor", "otherMalignancy", "radiation", "followUp", "newTumor-followUp"].indexOf(t) > -1){
            console.log("within clinical");
            console.log(count++);
            collection.distinct('patient_ID').then(function(ids){
              elem.ptIDs = elem.ptIDs.concat(ids).unique();
              //next();
              return elem;
            });
          }else if(["pcaScores", "mds"].indexOf(t) > -1){
            console.log("within pcaScores or mds");
            cursor.each(function(err, item){
              console.log(count++);
              if(item != null){
                elem.ptIDs = elem.ptIDs.concat(Object.keys(item.data)).unique();
              }else{
                return elem;
              }
            }); 
          }else if(t == "edges"){
            console.log("within edges");
            collection.distinct('p').then(function(ids){
              elem.ptIDs = elem.ptIDs.concat(ids).unique();
              return elem;
            }); 
          }else if(t == "ptDegree"){
            console.log("within ptDegree");
            cursor.each(function(err, item){
              console.log(count++);
              if(item != null){
                elem.ptIDs.push(Object.keys(item)[1]);
              }else{
                elem.ptIDs.unique();
                return elem;
              }
            });
          }else{
          console.log("&&&& THIS TYPE IS NOT INCLUDES: ", t);
          index += 1;
          return elem;
        }
        
        return elem;
        // status.push(elem);
      };
      // Call obtainPtIDs recursively
      // if(ptList[d.disease] != 0){
      //   obtainPtIDs();
      // }else{
      //   next();
      // }
    }, function (err)
    {
        if (err)
        {
            console.error('Error: ' + err.message);
            return;
        }
     
        console.log('Finished!');
    });
   
//});
 
 
 